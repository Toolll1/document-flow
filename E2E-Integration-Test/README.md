### Установка

Сначала удостоверьтесь, что проект подгрузился как модуль. Должен быть синий квадрат в правом нижнем углу корневой папки проекта тестов. Если нет, то читайте дальше.

Чтобы подгрузить дополнительный модуль:
1. Нажмите `Ctrl + Alt + Shift + S`,
2. Зайдите в `Modules`,
3. Нажмите на `+`,
4. Выберите `Import Module`,
5. Выберите в селекторе папку `E2E-Integration-Test`,
6. Появится окошко с двумя опциями, выберите вторую - `Import module from external model`. Выберите `Maven` из списка.
7. Нажмите `Create`. Модуль должен подгрузиться. Всё должно быть примерно как на скрине выше.

### Запуск

Запустите основной проект с профилями `dev`, `test`.

Чтобы запустить тесты, нажмите по корневой папке проекта и `Run 'All Tests'`. Тесты запустятся. Через `Maven test` пока не работает, потому что Maven не соблюдает очередность тестов.

### Архитектура

В проекте приоритетно используется **Package-by-Feature Architecture**. [Подробнее здесь](https://medium.com/sahibinden-technology/package-by-layer-vs-package-by-feature-7e89cde2ae3a). Если кратко:
В основном пакете находятся пакеты, распределенные по функциональности. Например, всё, что относится к юзеру в пакете `user`, всё, что относится к организации в `organization`, и так далее.

Сами тесты находятся в отдельном пакете. Тесты пользователя находятся в `userTests`, внутри вы можете увидеть несколько пакетов, они распределены по тестируемой функциональности. Порядок тестов должен идти строго сверху вниз. Если вашей функциональности нет, то создайте свой пакет. Очередность присваивается среднее между левым и правым. Например, если ваш пакет между 2000 и 3000, то присваивайте 1500.

### Как писать тесты

В пакете своей функциональности создаём класс, который наследует `BasicHttpTest`. Все тесты должны наследовать `BasicHttpTest`.
Это базовый абстрактный класс, который даёт контекст, через который можно передавать данные, и самого клиента для запросов.

Над классом ставим две аннотации:
`@DisplayName("Functionality name tests")` - в скобочках пишем, что тестируем (какой модуль).

Над каждым тестом также ставим `@DisplayName("Functionality name test")` с описанием, какой кейс тестируем.

**Контекст**

Контекст управляется с помощью двух методов:
`setContextValue(String key, Object value)` - добавить ваш объект в контекст,
`getContextValue(String key)` - получить объект из контекста.
Т.к ключи контейнера это строки, пожалуйста, используйте класс констант ([подробнее здесь](https://en.wikipedia.org/wiki/Constant_interface)) для хранения ключей. Пример такого класса - `Environment`, в корневом пакете.

Чтобы отправить запрос, используется `WebTestClient`. Есть две опции, чтобы его получить:
1. Функция `withNotAuthClient()` - вернёт клиента без авторизации.
2. Функция  `withAuthClient(String clientName)` - вернёт клиента с авторизацией, которую возьмёт из контекста. `clientName` - ключ объекта с токеном авторизации, объект должен являться экземпляром `UserAuthorizationResponse`.

И самое главное - переиспользуйте код по максимуму. Тесты не значит, что можно хардкодить и дублировать код. Создавайте классы, наследуйте их, выносите дубли в отдельные функции.

### База данных

**Установка**

Вам необходимо создать базу данных `document-flow-test`, и если у вас не рутовый юзер, то присвоить ему права на манипуляции с схемой `public`.

